{"ast":null,"code":"(function (TRUE, FALSE, NULL, undefined) {\n  var root = this; // Variablizing the strings for consistency\n  // and to avoid harmful dot-notation look-ups with\n  // javascript keywords\n\n  var sNull = 'Null',\n      sUndefined = 'Undefined',\n      sInfinity = 'Infinity',\n      sDate = 'Date',\n      sNaN = 'NaN',\n      sNumber = 'Number',\n      sString = 'String',\n      sObject = 'Object',\n      sArray = 'Array',\n      sRegExp = 'RegExp',\n      sBoolean = 'Boolean',\n      sFunction = 'Function',\n      sElement = 'Element'; // Utilizing the non-standard (but available in modern browsers) Global Object names\n  // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n  // Provide a polyfill for items without names\n\n  (function () {\n    var globalObjects = [sDate, sNumber, sString, sObject, sArray, sRegExp, sBoolean, sFunction, sElement],\n        idx = globalObjects.length,\n        globalObject;\n\n    while (idx--) {\n      globalObject = globalObjects[idx];\n\n      if (root[globalObject] !== undefined) {\n        if (!root[globalObject].name) {\n          root[globalObject].name = globalObject;\n        }\n      }\n    }\n  })();\n  /**\n   * Possible values\n   * @type {Object}\n   */\n\n\n  var _types = {};\n  _types[sNull] = 0;\n  _types[sUndefined] = 1;\n  _types[sInfinity] = 2;\n  _types[sDate] = 3;\n  _types[sNaN] = 4;\n  _types[sNumber] = 5;\n  _types[sString] = 6;\n  _types[sObject] = 7;\n  _types[sArray] = 8;\n  _types[sRegExp] = 9;\n  _types[sBoolean] = 10;\n  _types[sFunction] = 11;\n  _types[sElement] = 12;\n  /**\n   * Cached reference to Object.prototype.toString\n   * for type checking\n   * @type {Function}\n   */\n\n  var _toString = function (toString) {\n    return function (obj) {\n      return toString.call(obj);\n    };\n  }({}.toString),\n      _noopArr = [],\n\n  /**\n   * Type checks\n   */\n  _checkMap = function (map) {\n    var types = [// Only mapping items that need to be mapped.\n    // Items not in this list are doing faster\n    // (non-string) checks\n    //\n    // 0 = key, 1 = value\n    [sDate, _types[sDate]], [sNumber, _types[sNumber]], [sString, _types[sString]], [sObject, _types[sObject]], [sArray, _types[sArray]], [sRegExp, _types[sRegExp]], [sFunction, _types[sFunction]]],\n        idx = types.length;\n\n    while (idx--) {\n      map['[object ' + types[idx][0] + ']'] = types[idx][1];\n    }\n\n    return map;\n  }({}),\n\n  /**\n   * Mini extend\n   * @param  {Function} base\n   * @param  {Object}   obj\n   * @return {Function} base\n   */\n  extend = function extend(base, obj) {\n    var key;\n\n    for (key in obj) {\n      base[key] = obj[key];\n    }\n\n    return base;\n  };\n\n  var callLengths = {\n    0: function _(fn, args, context) {\n      if (!context) {\n        return fn();\n      }\n\n      return fn.call(context);\n    },\n    1: function _(fn, args, context) {\n      return fn.call(context, args[0]);\n    },\n    2: function _(fn, args, context) {\n      return fn.call(context, args[0], args[1]);\n    },\n    3: function _(fn, args, context) {\n      return fn.call(context, args[0], args[1], args[2]);\n    }\n  };\n\n  var caller = function caller(fn, args, context) {\n    var call = callLengths[args.length];\n\n    if (call) {\n      return call(fn, args, context);\n    }\n\n    return fn.apply(context, args);\n  };\n\n  var _getConfigurationType = function _getConfigurationType(val) {\n    if (val === null) {\n      return _types[sNull];\n    }\n\n    if (val === undefined) {\n      return _types[sUndefined];\n    } // we have something, but don't know what\n\n\n    if (!val.name) {\n      if (val === root[sElement]) {\n        return _types[sElement];\n      } // Firefox doesn't allow setting the name of Element\n\n\n      if (val !== +val) {\n        return _types[sNaN];\n      } // NaN check\n\n\n      return _types[sInfinity]; // Infinity check\n    }\n\n    return _types[val.name];\n  };\n\n  var _getParameterType = function _getParameterType(val) {\n    if (val === null) {\n      return _types[sNull];\n    }\n\n    if (val === undefined) {\n      return _types[sUndefined];\n    }\n\n    if (val === TRUE || val === FALSE) {\n      return _types[sBoolean];\n    }\n\n    if (val && val.nodeType === 1) {\n      return _types[sElement];\n    } // Element check from Underscore\n\n\n    var typeString = _toString(val);\n\n    if (_checkMap[typeString] === _types[sNumber]) {\n      if (val !== +val) {\n        return _types[sNaN];\n      } // NaN check\n\n\n      if (!isFinite(val)) {\n        return _types[sInfinity];\n      } // Finite check\n\n\n      return _types[sNumber]; // definitely a number\n    }\n\n    return _checkMap[typeString];\n  };\n\n  var _convertConfigurationTypes = function _convertConfigurationTypes(args) {\n    var parameters = [],\n        idx = 0,\n        length = args.length,\n        configItem;\n\n    for (; idx < length; idx++) {\n      configItem = args[idx];\n      parameters.push(configItem instanceof Custom ? configItem : _getConfigurationType(configItem));\n    }\n\n    return parameters;\n  };\n\n  var _convertConfigurationMap = function _convertConfigurationMap(map) {\n    var parameters = {},\n        key,\n        configItem;\n\n    for (key in map) {\n      configItem = map[key];\n      parameters[key] = configItem instanceof Custom ? configItem : _getConfigurationType(configItem);\n    }\n\n    return parameters;\n  };\n\n  var _convertParametersTypes = function _convertParametersTypes(args) {\n    var parameters = [],\n        idx = 0,\n        length = args.length;\n\n    for (; idx < length; idx++) {\n      parameters.push(_getParameterType(args[idx]));\n    }\n\n    return parameters;\n  };\n\n  var _doesMapMatchArgsTypes = function _doesMapMatchArgsTypes(map, argTypes, args) {\n    var mapLength = map.length,\n        argLength = argTypes.length;\n\n    if (mapLength === 0 && argLength === 0) {\n      return TRUE;\n    }\n\n    if (mapLength !== argLength) {\n      return FALSE;\n    }\n\n    var idx = 0,\n        mapItem;\n\n    for (; idx < argLength; idx++) {\n      mapItem = map[idx];\n\n      if (mapItem instanceof Custom) {\n        if (mapItem.check(args[idx])) {\n          continue;\n        }\n\n        return FALSE;\n      }\n\n      if (argTypes[idx] !== mapItem) {\n        return FALSE;\n      }\n    }\n\n    return TRUE;\n  };\n\n  var _getArgumentMatch = function _getArgumentMatch(mappings, args) {\n    if (!mappings) {\n      return;\n    }\n\n    var argTypes = _convertParametersTypes(args),\n        idx = 0,\n        length = mappings.length;\n\n    for (; idx < length; idx++) {\n      if (_doesMapMatchArgsTypes(mappings[idx].params, argTypes, args)) {\n        return mappings[idx];\n      }\n    }\n  };\n\n  var _getLengthMatch = function _getLengthMatch(mappings, args) {\n    if (!mappings) {\n      return;\n    }\n\n    var argLength = args.length,\n        idx = 0,\n        length = mappings.length;\n\n    for (; idx < length; idx++) {\n      if (mappings[idx].length === argLength) {\n        return mappings[idx];\n      }\n    }\n  };\n\n  var _matchAny = function _matchAny(args, val) {\n    var type = _getParameterType(val),\n        idx = args.length,\n        mapItem;\n\n    while (idx--) {\n      mapItem = args[idx];\n\n      if (mapItem instanceof Custom) {\n        if (mapItem.check(val)) {\n          return TRUE;\n        }\n\n        continue;\n      }\n\n      if (args[idx] === type) {\n        return TRUE;\n      }\n    }\n\n    return FALSE;\n  };\n\n  var _matchMap = function _matchMap(config, map) {\n    var key, configItem, mapItem;\n\n    for (key in config) {\n      configItem = config[key];\n      mapItem = map[key];\n\n      if (configItem instanceof Custom) {\n        if (!configItem.check(mapItem)) {\n          return FALSE;\n        }\n\n        continue;\n      }\n\n      if (configItem !== _getParameterType(mapItem)) {\n        return FALSE;\n      }\n    }\n\n    return TRUE;\n  };\n  /**\n   * Custom type that validates a value\n   * @constructor\n   * @param {Function} check\n   */\n\n\n  var Custom = function Custom(check) {\n    this.check = check;\n  };\n\n  var o = {\n    wild: new Custom(function () {\n      return TRUE;\n    }),\n    truthy: new Custom(function (val) {\n      return !!val === TRUE;\n    }),\n    falsy: new Custom(function (val) {\n      return !!val === FALSE;\n    }),\n    any: function any() {\n      var args = _convertConfigurationTypes(arguments);\n\n      return new Custom(function (val) {\n        return _matchAny(args, val);\n      });\n    },\n    except: function except() {\n      var args = _convertConfigurationTypes(arguments);\n\n      return new Custom(function (val) {\n        return !_matchAny(args, val);\n      });\n    },\n    map: function map(_map) {\n      var mapConfig = _convertConfigurationMap(_map);\n\n      return new Custom(function (map) {\n        return _matchMap(mapConfig, map);\n      });\n    }\n  };\n  var fn = {\n    /**\n     * Methods mapped to argument types\n     * Lazily instanciated\n     * @type {Array} argument mapping\n     */\n    // this._m;\n\n    /**\n     * Methods mapped to argument lengths\n     * Lazily instanciated\n     * @type {Array} length mapping\n     */\n    // this._l;\n\n    /**\n     * A fallback function if none\n     * of the criteria match on a call\n     * @type {Function}\n     */\n    // this._f;\n    map: function map(_map2) {\n      var self = this;\n      return {\n        use: function use(method) {\n          var argMappings = self._m || (self._m = []);\n          argMappings.push({\n            params: [o.map(_map2)],\n            method: method\n          });\n          return self;\n        }\n      };\n    },\n    args: function args() {\n      var self = this,\n          args = arguments;\n      return {\n        use: function use(method) {\n          var argMappings = self._m || (self._m = []);\n          argMappings.push({\n            params: _convertConfigurationTypes(args),\n            method: method\n          });\n          return self;\n        }\n      };\n    },\n    len: function len(num) {\n      var self = this;\n      return {\n        use: function use(method) {\n          var lengthMappings = self._l || (self._l = []);\n          lengthMappings.push({\n            length: num === undefined ? method.length : num,\n            method: method\n          });\n          return self;\n        }\n      };\n    },\n    error: function error(method) {\n      this._err = method;\n      return this;\n    },\n    fallback: function fallback(method) {\n      this._f = method;\n      return this;\n    },\n    call: function call() {\n      // prevent function deoptimation\n      var args = arguments,\n          a = [];\n\n      for (var idx = 1, length = args.length; idx < length; idx++) {\n        a[idx] = args[idx];\n      }\n\n      return this._call(args[0], a);\n    },\n    apply: function apply(context, args) {\n      var a = args;\n\n      if (args && args.callee) {\n        // passed an arguments object,\n        // not an array.\n        // prevent function deoptimation\n        a = [];\n\n        for (var idx = 0, length = args.length; idx < length; idx++) {\n          a[idx] = args[idx];\n        }\n      }\n\n      return this._call(context, a);\n    },\n    bind: function bind(context) {\n      var self = this;\n      return function () {\n        // prevent function deoptimation\n        var args = arguments,\n            a = [];\n\n        for (var idx = 0, length = args.length; idx < length; idx++) {\n          a[idx] = args[idx];\n        }\n\n        return self._call(context, a);\n      };\n    },\n    expose: function expose() {\n      var self = this;\n      return function () {\n        // prevent function deoptimation\n        var args = arguments,\n            a = [];\n\n        for (var idx = 0, length = args.length; idx < length; idx++) {\n          a[idx] = args[idx];\n        }\n\n        return self._call(this, a);\n      };\n    },\n    _call: function _call(context, args) {\n      if (context === root) {\n        context = null;\n      }\n\n      args = args || _noopArr; // Any argument match, of course, already matches\n      // the length match, so this should be done first\n\n      var argMatch = _getArgumentMatch(this._m, args);\n\n      if (argMatch) {\n        return caller(argMatch.method, args, context);\n      } // Check for a length match\n\n\n      var lengthMatch = _getLengthMatch(this._l, args);\n\n      if (lengthMatch) {\n        return caller(lengthMatch.method, args, context);\n      } // Check for a fallback\n\n\n      if (this._f) {\n        return caller(this._f, args, context);\n      } // Error\n\n\n      return this._err ? this._err(args) : api.err;\n    }\n  };\n  fn.fail = fn.err = fn.error;\n  fn.count = fn.size = fn.len;\n\n  var api = function api() {\n    var overload = function overload() {\n      return overload._call(overload, arguments);\n    };\n\n    return extend(overload, fn);\n  };\n\n  api.o = o;\n  api.fn = fn;\n\n  api.err = function () {\n    throw 'overload - exception: No methods matched';\n  };\n\n  api.define = api.defineType = function (name, check) {\n    var custom = new Custom(check);\n    return o[name] = custom;\n  };\n\n  api.defineTypes = function (obj) {\n    var key;\n\n    for (key in obj) {\n      api.define(key, obj[key]);\n    }\n\n    return api;\n  };\n\n  if (typeof define === 'function') {\n    // RequireJS\n    define(function () {\n      return api;\n    });\n  } else if (typeof module !== 'undefined' && module.exports) {\n    // CommonJS\n    module.exports = api;\n  } else {\n    root.overload = api;\n    root.o = o;\n  }\n})(true, false, null);","map":null,"metadata":{},"sourceType":"script"}